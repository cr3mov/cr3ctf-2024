# Writeup

To fully describe the metro scheme, we can consider all possible pairs of the form (vertical segment + horizontal segment). Each segment has three degrees of freedom: start, end, and the number of the row or column it belongs to. Therefore, a pair of such segments will have 6 degrees of freedom. We will iterate through all combinations of these parameters using nested loops, leaving only those combinations where the segments have a common square, and calculate the answer for each variant. Among all the answers, we will choose the maximum one. Depending on the implementation, such a solution may have a complexity of $O(n^3 \cdot m^3)$ or $O(n^4 \cdot m^4)$ and will correctly work on all tests where $n \leq 10; m \leq 10$.

To improve the solution, we optimize the enumeration. We iterate through the central point of intersection of two segments. Then, for each of these points, we find its optimal extension upwards, downwards, leftwards, and rightwards. Starting from the second cell in any direction, these values will be completely independent of each other. Therefore, among all extensions in the same direction, the optimal one can be selected in time $O(n)$ or $O(m)$. We do the same symmetrically for all four sides. Removals in perpendicular directions are not independent due to corner cells (cells adjacent to the central one at the corner but not on the side). To solve the problem with them, we can pre-determine whether each direction is used or not. The corner cell is included when at least one of the adjacent directions is included. This way, we can iterate through $2×2×2×2 = 16$ options for all directions and determine the answer for each of them. Combining the two previous paragraphs, we can make a solution with a time complexity of $O(n \cdot m \cdot (n + m))$. Such a solution will work for all tests where $n \leq 100; m \leq 100$.

In the case when $a_i \leq 1$, we have only two possible values for $a_i$, zero or one. In this case, for a fixed central point and a fixed direction, only one of the following makes sense:
1. Extend in this direction until the last encountered one;
2. Extend in this direction to the field boundary.
Thus, by pre-calculating for each row and column the first and last one, as well as partial sums on all columns and rows, we can determine the optimal result for one direction in $O(1)$. Hence, we can make a solution with a time complexity of $O(n \cdot m)$. For a complete solution, we also need to be able to compute the result for each point in $O(1)$. To do this, we also need to be able to compute the optimal value in the direction from the given point, but we can recalculate this value from the value of the adjacent point in the same direction using dynamic programming across all rows and columns in both directions. The time complexity of such a solution is $O(n \cdot m)$.
